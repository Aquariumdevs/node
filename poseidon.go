package main

// #cgo LDFLAGS: -L. -lsimple_example -ldl
// #include <stdint.h>
//
// typedef struct {
//     uint64_t limbs[4];
// } Fp;
//
// Fp hashp(Fp fp);
//
// Fp hashpd(Fp* out, Fp fp, Fp fpd);
//
// Fp logfp(Fp fp);
//
// typedef struct MerkleNode {
//     Fp hash;
//     struct MerkleNode* left;
//     struct MerkleNode* right;
// } MerkleNode;
//
// MerkleNode* create_merkle_tree(const Fp* data, size_t count);
// void add_leaf_to_tree(Fp new_leaf);
// Fp get_merkle_root();
// void clear_merkle_tree();
// unsigned int get_merkle_path(size_t leaf_index, Fp* out_path, size_t* out_path_len);
import "C"
import (
	"encoding/binary"
	"errors"
	"fmt"
	"unsafe"

	"go.vocdoni.io/dvote/db"
	// "go.vocdoni.io/dvote/db/badgerdb"
)

type MerkleTree struct {
	db         db.Database
	keyIndex   map[string]int
	values     [][]byte
	currentIdx int
}

func fpToBytes(fp *C.Fp) []byte {
	size := unsafe.Sizeof(*fp)
	byteSlice := (*[1 << 30]byte)(unsafe.Pointer(fp))[:size:size]
	return byteSlice
}

func bytesToFp(value []byte) C.Fp {
	fp := (*C.Fp)(unsafe.Pointer(&value[0]))
	return *fp
}

/*
//safe alternative
func fpToBytes(fp *C.Fp) []byte {
	// Convert the C.Fp struct to a byte slice
	size := int(unsafe.Sizeof(*fp))
	byteSlice := make([]byte, size)
	for i := 0; i < 4; i++ {
		binary.LittleEndian.PutUint64(byteSlice[i*8:], uint64(fp.limbs[i]))
	}
	return byteSlice
}

func bytesToFp(value []byte) C.Fp {
	if len(value) != 32 { // 4 * 8 bytes = 32 bytes
		panic("invalid length of byte slice")
	}
	var fp C.Fp
	for i := 0; i < 4; i++ {
		fp.limbs[i] = C.uint64_t(binary.LittleEndian.Uint64(value[i*8:]))
	}
	return fp
}
*/
// to32ByteArray converts a byte slice to a [32]byte array, right-padded with zeros if necessary.
func to32ByteArray(data []byte) [32]byte {
	var array [32]byte
	copy(array[:], data)
	return array
}

func NewMerkleTree(database db.Database) *MerkleTree {
	tree := &MerkleTree{
		db:       database,
		keyIndex: make(map[string]int),
		values:   make([][]byte, 0),
	}
	tree.clear()
	return tree
}

func (tree *MerkleTree) Add(key, value []byte) error {
	keyStr := string(key)
	if _, exists := tree.keyIndex[keyStr]; exists {
		return errors.New("key already exists")
	}

	tree.keyIndex[keyStr] = tree.currentIdx
	tree.values = append(tree.values, value)
	tree.currentIdx++

	fmt.Printf("Adding leaf: %v\n", value)
	logFp(bytesToFp(value))

	C.add_leaf_to_tree(bytesToFp(value))

	txn := tree.db.WriteTx()
	defer txn.Discard()

	indexBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(indexBytes, uint64(tree.keyIndex[keyStr]))

	fmt.Printf("Storing index for key %v: %v\n", key, indexBytes)
	if err := txn.Set(append([]byte("index_"), key...), indexBytes); err != nil {
		fmt.Printf("Failed to store index for key %v: %v\n", key, err)
		return err
	}

	fmt.Printf("Storing value for key %v: %v\n", key, value)
	if err := txn.Set(append([]byte("value_"), key...), value); err != nil {
		fmt.Printf("Failed to store value for key %v: %v\n", key, err)
		return err
	}

	if err := txn.Commit(); err != nil {
		fmt.Printf("Failed to commit transaction: %v\n", err)
		return err
	}

	fmt.Printf("Successfully added key %v with value %v\n", key, value)
	return nil
}

func (tree *MerkleTree) GenProof(key []byte) ([]byte, []byte, []byte, error) {
	keyStr := string(key)
	idx, exists := tree.keyIndex[keyStr]
	fmt.Println("GenProof key:", key)
	fmt.Println("GenProof key index:", idx)

	if !exists {
		fmt.Println("Key does not exist:", key)
		return nil, nil, nil, errors.New("key does not exist")
	}

	fmt.Println("GenProof key exists:", key)
	fmt.Println("values length:", len(tree.values))

	// Handle small trees with only 2 leaves
	if len(tree.values) == 2 {
		fmt.Println("Small tree with only 2 leaves")
		var bytePath []byte
		bytePath = append(bytePath, byte(2))

		for _, value := range tree.values {
			bytePath = append(bytePath, value...)
		}

		fmt.Println("Generated bytePath for small tree:", bytePath)
		return []byte(keyStr), bytePath, bytePath, nil
	}

	merklePath, err := getMerklePath(uint(idx))
	if err != nil {
		fmt.Println("Failed to get Merkle path for key:", key, "error:", err)
		return nil, nil, nil, err
	}
	fmt.Println("Merkle path for key:", key, "merklePath:", merklePath)

	var bytePath []byte
	bytePath = append(bytePath, byte(len(merklePath)))
	fmt.Println("Initial bytePath (length byte):", bytePath)

	for _, fp := range merklePath {
		bytePath = append(bytePath, fpToBytes(&fp)...)
	}
	fmt.Println("Final bytePath:", bytePath)

	return []byte(keyStr), bytePath, bytePath, nil
}

func (tree *MerkleTree) Root() ([]byte, error) {
	if len(tree.values) == 2 {
		fmt.Println("Small tree with 2 leaves detected. Using Poseidon to calculate root.")
		poseidonRoot, err := tree.Poseidon(tree.values)
		if err != nil {
			fmt.Println("Failed to calculate Poseidon root:", err)
			return nil, err
		}
		return poseidonRoot, nil
	}

	rootFp := C.get_merkle_root()
	return fpToBytes(&rootFp), nil //TODO: error handling
}

func (tree *MerkleTree) poseidon(values ...[]byte) ([]byte, error) {
	return tree.Poseidon(values)
}

func (tree *MerkleTree) Poseidon(values [][]byte) ([]byte, error) {
	C.clear_merkle_tree()
	if len(values) == 0 {
		return nil, errors.New("no value to hash")
	}

	flatValues := make([]C.Fp, len(values), len(values)*32)
	for i, value := range values {
		b := to32ByteArray(value)
		flatValues[i] = bytesToFp(b[:])

		fmt.Printf("Adding leaf %d : ", i)
		logFp(flatValues[i])
	}

	ptr := (*C.Fp)(unsafe.Pointer(&flatValues[0]))
	resultFp := C.create_merkle_tree(ptr, C.size_t(len(values)))

	fmt.Printf("root: ")
	logFp(resultFp.hash)

	return fpToBytes(&resultFp.hash), nil
}

func (tree *MerkleTree) AddBatch(keys, values [][]byte) error {
	if len(keys) != len(values) {
		return errors.New("keys and values length mismatch")
	}

	if len(keys) == 0 {
		return nil
	}

	// Handle the case where there's only one leaf
	if len(keys) == 1 {
		fmt.Println("Only one leaf, using Add instead of AddBatch")
		return tree.Add(keys[0], values[0])
	}

	txn := tree.db.WriteTx()
	defer txn.Discard()

	for i := 0; i < len(keys); i++ {
		keyStr := string(keys[i])
		fmt.Printf("Processing key: %v\n", keys[i])

		if _, exists := tree.keyIndex[keyStr]; exists {
			return errors.New("key already exists")
		}

		tree.keyIndex[keyStr] = tree.currentIdx

		indexBytes := make([]byte, 8)
		binary.LittleEndian.PutUint64(indexBytes, uint64(tree.keyIndex[keyStr]))

		fmt.Printf("Storing index for key %v: %v\n", keys[i], indexBytes)
		if err := txn.Set(append([]byte("index_"), keys[i]...), indexBytes); err != nil {
			fmt.Printf("Failed to store index for key %v: %v\n", keys[i], err)
			return err
		}

		fmt.Printf("Storing value for key %v: %v\n", keys[i], values[i])
		if err := txn.Set(append([]byte("value_"), keys[i]...), values[i]); err != nil {
			fmt.Printf("Failed to store value for key %v: %v\n", keys[i], err)
			return err
		}

		tree.currentIdx++
	}

	flatValues := make([]C.Fp, len(values))
	for i, value := range values {
		flatValues[i] = bytesToFp(value)
		fmt.Printf("Batch adding leaf %d: %v\n", i, value)
		logFp(bytesToFp(value))
	}

	ptr := (*C.Fp)(unsafe.Pointer(&flatValues[0]))
	C.create_merkle_tree(ptr, C.size_t(len(values)))

	if err := txn.Commit(); err != nil {
		fmt.Printf("Failed to commit transaction: %v\n", err)
		return err
	}

	fmt.Printf("Successfully added batch keys: %v with values: %v\n", keys, values)
	return nil
}

/*
	func (tree *MerkleTree) AddBatch(keys, values [][]byte) error {
		if len(keys) != len(values) {
			return errors.New("keys and values length mismatch")
		}

		if len(keys) == 0 {
			return nil
		}

		for i := 0; i < len(keys); i++ {
			keyStr := string(keys[i])
			fmt.Println("str=", keys[i])

			if _, exists := tree.keyIndex[keyStr]; exists {
				return errors.New("key already exists")
			}

			tree.keyIndex[keyStr] = tree.currentIdx
			tree.currentIdx++
		}

		flatValues := make([]C.Fp, len(values))
		for i, value := range values {
			flatValues[i] = bytesToFp(value)

			fmt.Printf("Batch adding leaf %d : ", i)
			logFp(bytesToFp(value))
		}

		ptr := (*C.Fp)(unsafe.Pointer(&flatValues[0]))
		C.create_merkle_tree(ptr, C.size_t(len(values)))

		return nil
	}
*/
func getMerklePath(leafIndex uint) ([]C.Fp, error) {
	const maxPathLength = 256
	outPath := make([]C.Fp, maxPathLength)
	outPathLen := C.size_t(maxPathLength)

	ret := C.get_merkle_path(C.size_t(leafIndex), (*C.Fp)(unsafe.Pointer(&outPath[0])), &outPathLen)
	if ret != 0 {
		return nil, fmt.Errorf("failed to get merkle path")
	}

	goPath := make([]C.Fp, outPathLen)
	copy(goPath, outPath[:outPathLen])

	return goPath, nil
}

func logFp(fp C.Fp) {
	C.logfp(fp)
}

func logBytes(b []byte) {
	fp := *(*C.Fp)(unsafe.Pointer(&b[0]))
	logFp(fp)
}

func printMerklePath(path []C.Fp) {
	for _, element := range path {
		logFp(element)
	}
}

func (tree *MerkleTree) RecoverTree() error {
	tree.clear()

	keys := make([][]byte, 0)
	tree.values = make([][]byte, 0)

	txn := tree.db.ReadTx()
	defer txn.Discard()

	err := tree.db.Iterate(nil, func(k, v []byte) bool {
		fmt.Printf("Iterating key: %v, value: %v\n", k, v)
		if string(k[:6]) == "index_" {
			index := binary.LittleEndian.Uint64(v)
			key := k[6:] // Remove "index_" prefix
			tree.keyIndex[string(key)] = int(index)
			fmt.Printf("Recovered index for key %v: %d\n", key, index)
			keys = append(keys, append([]byte{}, key...)) // Ensure keys are copied properly
			return true
		}
		if string(k[:6]) == "value_" {
			value := append([]byte{}, v...)
			tree.values = append(tree.values, value) // Ensure tree.values are copied properly
			fmt.Printf("Recovered value for key %v: %v\n", k[6:], value)
			return true
		}
		return false
	})

	if err != nil {
		fmt.Printf("Failed during iteration: %v\n", err)
		return err
	}

	fmt.Printf("Recovered keys: %v\n", keys)
	fmt.Printf("Recovered values: %v\n", tree.values)

	if len(tree.keyIndex) > 0 {
		maxIndex := 0
		for _, idx := range tree.keyIndex {
			if idx > maxIndex {
				maxIndex = idx
			}
		}
		tree.currentIdx = maxIndex + 1
	} else {
		tree.currentIdx = 0
	}

	fmt.Printf("Recovered tree.currentIdx: %d\n", tree.currentIdx)

	// Only recreate the Merkle tree if there are values to process
	if len(tree.values) > 0 {
		// Add the collected leaves in a batch to the internal Rust structure
		flatValues := make([]C.Fp, len(tree.values))
		for i, value := range tree.values {
			flatValues[i] = bytesToFp(value)
		}

		ptr := (*C.Fp)(unsafe.Pointer(&flatValues[0]))
		fmt.Printf("Calling create_merkle_tree with %d values\n", len(tree.values))
		C.create_merkle_tree(ptr, C.size_t(len(tree.values)))
		fmt.Println("Successfully called create_merkle_tree.")
	} else {
		fmt.Println("No values to add to the Merkle tree. Skipping create_merkle_tree call.")
	}

	return nil
}

func (tree *MerkleTree) clear() {
	C.clear_merkle_tree()
	tree.keyIndex = make(map[string]int)
	tree.values = nil
	tree.currentIdx = 0
}
